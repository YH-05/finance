"""NoteService for NotebookLM note CRUD operations.

This module provides ``NoteService``, which orchestrates Playwright
browser operations for creating, listing, retrieving, and deleting
notes (memos) in NotebookLM notebooks.

Architecture
------------
The service receives a ``NotebookLMBrowserManager`` via dependency injection
and uses ``SelectorManager`` for resilient element lookup with fallback
selector chains.

Each operation:
1. Creates a new browser page from the shared context.
2. Navigates to the target notebook.
3. Performs UI interactions for note management.
4. Extracts data from the page DOM.
5. Returns typed Pydantic models.
6. Closes the page in a ``finally`` block.

Examples
--------
>>> from notebooklm.browser import NotebookLMBrowserManager
>>> from notebooklm.services.note import NoteService
>>>
>>> async with NotebookLMBrowserManager() as manager:
...     service = NoteService(manager)
...     note = await service.create_note(
...         notebook_id="abc-123",
...         content="Key observations from research.",
...     )
...     print(note.note_id)

See Also
--------
notebooklm.browser.manager : Browser lifecycle management.
notebooklm.browser.helpers : Page operation helpers.
notebooklm.selectors : CSS selector management.
"""

from __future__ import annotations

import asyncio
import uuid
from typing import TYPE_CHECKING, Any

from notebooklm.browser.helpers import (
    click_with_fallback,
    extract_text,
    navigate_to_notebook,
    wait_for_element,
)
from notebooklm.constants import DEFAULT_ELEMENT_TIMEOUT_MS
from notebooklm.errors import NotebookLMError
from notebooklm.selectors import SelectorManager
from notebooklm.types import NoteContent, NoteInfo
from utils_core.logging import get_logger

if TYPE_CHECKING:
    from notebooklm.browser.manager import NotebookLMBrowserManager

logger = get_logger(__name__)

# CSS selectors for note list elements (note cards in the notes panel)
_NOTE_LIST_SELECTOR = ".note-item, [data-type='note-item'], .note-card"


class NoteService:
    """Service for NotebookLM note (memo) CRUD operations.

    Provides methods for creating, listing, retrieving, and deleting
    notes in NotebookLM notebooks via Playwright browser automation.

    Parameters
    ----------
    browser_manager : NotebookLMBrowserManager
        Initialized browser manager for page creation.

    Attributes
    ----------
    _browser_manager : NotebookLMBrowserManager
        The injected browser manager.
    _selectors : SelectorManager
        Selector registry for UI element lookup.

    Examples
    --------
    >>> async with NotebookLMBrowserManager() as manager:
    ...     service = NoteService(manager)
    ...     notes = await service.list_notes("abc-123")
    ...     for note in notes:
    ...         print(f"{note.title} ({note.note_id})")
    """

    def __init__(self, browser_manager: NotebookLMBrowserManager) -> None:
        self._browser_manager = browser_manager
        self._selectors = SelectorManager()

        logger.debug("NoteService initialized")

    async def create_note(
        self,
        notebook_id: str,
        content: str,
        title: str | None = None,
    ) -> NoteInfo:
        """Create a new plain text note in a notebook.

        Navigates to the notebook page, clicks the "Add note" button,
        fills in the title (if provided) and content, then returns
        the created note's metadata.

        Parameters
        ----------
        notebook_id : str
            UUID of the target notebook. Must not be empty.
        content : str
            Text content for the note. Must not be empty.
        title : str | None
            Optional display title for the note.
            If None, the note title is auto-generated by NotebookLM.

        Returns
        -------
        NoteInfo
            Metadata for the newly created note.

        Raises
        ------
        ValueError
            If ``notebook_id`` or ``content`` is empty.
        NotebookLMError
            If the note cannot be created due to a browser error.
        SessionExpiredError
            If the browser session has expired.

        Examples
        --------
        >>> note = await service.create_note(
        ...     notebook_id="abc-123",
        ...     content="Key observations from research.",
        ...     title="Research Notes",
        ... )
        >>> print(note.note_id)
        """
        if not notebook_id.strip():
            raise ValueError("notebook_id must not be empty")
        if not content.strip():
            raise ValueError("content must not be empty")

        effective_title = title or "Untitled Note"

        logger.info(
            "Creating note",
            notebook_id=notebook_id,
            title=effective_title,
            content_length=len(content),
        )

        page = await self._browser_manager.new_page()
        try:
            # Navigate to the notebook
            await navigate_to_notebook(page, notebook_id)
            await page.wait_for_load_state("networkidle")

            # Click "Add note" button
            add_note_selectors = self._selectors.get_selector_strings("note_add_button")
            await click_with_fallback(
                page,
                add_note_selectors,
                timeout_ms=DEFAULT_ELEMENT_TIMEOUT_MS,
            )

            # Small delay for the note editor to open
            await asyncio.sleep(0.5)

            # Fill in title if provided
            if title is not None:
                title_selectors = self._selectors.get_selector_strings(
                    "note_title_input"
                )
                title_element = await wait_for_element(
                    page,
                    title_selectors,
                    timeout_ms=DEFAULT_ELEMENT_TIMEOUT_MS,
                )
                await title_element.fill(title)

            # Fill in the content using the note editor
            editor_selectors = self._selectors.get_selector_strings(
                "note_editor_manual"
            )
            editor_element = await wait_for_element(
                page,
                editor_selectors,
                timeout_ms=DEFAULT_ELEMENT_TIMEOUT_MS,
            )
            await editor_element.fill(content)

            # Allow the note to save (NotebookLM auto-saves)
            await asyncio.sleep(1.0)

            # Generate a note ID (NotebookLM doesn't expose IDs easily)
            note_id = f"note-{uuid.uuid4().hex[:8]}"

            logger.info(
                "Note created",
                notebook_id=notebook_id,
                note_id=note_id,
                title=effective_title,
            )

            return NoteInfo(
                note_id=note_id,
                title=effective_title,
            )

        except Exception as e:
            if isinstance(e, ValueError):
                raise
            raise NotebookLMError(
                f"Failed to create note: {e}",
                context={
                    "notebook_id": notebook_id,
                    "content_length": len(content),
                    "error": str(e),
                },
            ) from e
        finally:
            await page.close()

    async def list_notes(
        self,
        notebook_id: str,
    ) -> list[NoteInfo]:
        """List all notes in a notebook.

        Navigates to the notebook page and scrapes the notes panel
        to extract metadata for each note.

        Parameters
        ----------
        notebook_id : str
            UUID of the target notebook. Must not be empty.

        Returns
        -------
        list[NoteInfo]
            List of note metadata, ordered as displayed on the page.

        Raises
        ------
        ValueError
            If ``notebook_id`` is empty.
        SessionExpiredError
            If the browser session has expired.

        Examples
        --------
        >>> notes = await service.list_notes("abc-123")
        >>> for note in notes:
        ...     print(f"{note.title} ({note.note_id})")
        """
        if not notebook_id.strip():
            raise ValueError("notebook_id must not be empty")

        logger.info("Listing notes", notebook_id=notebook_id)

        page = await self._browser_manager.new_page()
        try:
            # Navigate to the notebook
            await navigate_to_notebook(page, notebook_id)
            await page.wait_for_load_state("networkidle")

            # Find note items in the notes panel
            note_elements = await page.locator(_NOTE_LIST_SELECTOR).all()

            notes: list[NoteInfo] = []
            for idx, element in enumerate(note_elements):
                title = await element.inner_text()
                title = title.strip() if title else "Untitled Note"

                note_id = f"note-{idx:03d}"

                notes.append(
                    NoteInfo(
                        note_id=note_id,
                        title=title,
                    )
                )

            logger.info(
                "Notes listed",
                notebook_id=notebook_id,
                count=len(notes),
            )
            return notes

        finally:
            await page.close()

    async def get_note(
        self,
        notebook_id: str,
        note_index: int,
    ) -> NoteContent:
        """Get the full content of a specific note.

        Navigates to the notebook page, clicks on the note at the
        given index to open it, and extracts the title and content.

        Parameters
        ----------
        notebook_id : str
            UUID of the target notebook. Must not be empty.
        note_index : int
            Zero-based index of the note in the notes list.
            Must be non-negative.

        Returns
        -------
        NoteContent
            Full content of the note including title and body text.

        Raises
        ------
        ValueError
            If ``notebook_id`` is empty or ``note_index`` is negative
            or out of range.
        NotebookLMError
            If the note content cannot be retrieved.
        SessionExpiredError
            If the browser session has expired.

        Examples
        --------
        >>> note = await service.get_note("abc-123", note_index=0)
        >>> print(note.title)
        >>> print(note.content)
        """
        if not notebook_id.strip():
            raise ValueError("notebook_id must not be empty")
        if note_index < 0:
            raise ValueError("note_index must be non-negative")

        logger.info(
            "Getting note",
            notebook_id=notebook_id,
            note_index=note_index,
        )

        page = await self._browser_manager.new_page()
        try:
            await navigate_to_notebook(page, notebook_id)
            await page.wait_for_load_state("networkidle")

            # Find note items
            note_elements = await page.locator(_NOTE_LIST_SELECTOR).all()

            if note_index >= len(note_elements):
                raise ValueError(
                    f"note_index {note_index} out of range "
                    f"(notebook has {len(note_elements)} notes)"
                )

            # Click on the note to open it
            note_element = note_elements[note_index]
            title = await note_element.inner_text()
            title = title.strip() if title else "Untitled Note"

            await note_element.click()
            await asyncio.sleep(1.0)

            # Extract content from the editor or readonly viewer
            content = await self._extract_note_content(page)

            note_id = f"note-{note_index:03d}"

            logger.info(
                "Note retrieved",
                notebook_id=notebook_id,
                note_id=note_id,
                title=title,
                content_length=len(content),
            )

            return NoteContent(
                note_id=note_id,
                title=title,
                content=content,
            )

        except Exception as e:
            if isinstance(e, ValueError):
                raise
            raise NotebookLMError(
                f"Failed to get note: {e}",
                context={
                    "notebook_id": notebook_id,
                    "note_index": note_index,
                    "error": str(e),
                },
            ) from e
        finally:
            await page.close()

    async def delete_note(
        self,
        notebook_id: str,
        note_index: int,
    ) -> bool:
        """Delete a note from a notebook.

        Navigates to the notebook page, locates the note at the given
        index, clicks the delete button, and confirms deletion.

        Parameters
        ----------
        notebook_id : str
            UUID of the target notebook. Must not be empty.
        note_index : int
            Zero-based index of the note to delete.
            Must be non-negative.

        Returns
        -------
        bool
            True if the note was deleted successfully.

        Raises
        ------
        ValueError
            If ``notebook_id`` is empty or ``note_index`` is negative
            or out of range.
        NotebookLMError
            If the note cannot be deleted.
        SessionExpiredError
            If the browser session has expired.

        Examples
        --------
        >>> deleted = await service.delete_note("abc-123", note_index=0)
        >>> print(deleted)
        True
        """
        if not notebook_id.strip():
            raise ValueError("notebook_id must not be empty")
        if note_index < 0:
            raise ValueError("note_index must be non-negative")

        logger.info(
            "Deleting note",
            notebook_id=notebook_id,
            note_index=note_index,
        )

        page = await self._browser_manager.new_page()
        try:
            await navigate_to_notebook(page, notebook_id)
            await page.wait_for_load_state("networkidle")

            # Find note items
            note_elements = await page.locator(_NOTE_LIST_SELECTOR).all()

            if note_index >= len(note_elements):
                raise ValueError(
                    f"note_index {note_index} out of range "
                    f"(notebook has {len(note_elements)} notes)"
                )

            # Hover over the note to reveal action buttons
            note_element = note_elements[note_index]
            await note_element.hover()
            await asyncio.sleep(0.3)

            # Click the delete button
            delete_selectors = self._selectors.get_selector_strings(
                "note_delete_button"
            )
            await click_with_fallback(
                page,
                delete_selectors,
                timeout_ms=DEFAULT_ELEMENT_TIMEOUT_MS,
            )

            await asyncio.sleep(0.3)

            # Confirm deletion
            confirm_selectors = self._selectors.get_selector_strings(
                "note_delete_confirm_button"
            )
            await click_with_fallback(
                page,
                confirm_selectors,
                timeout_ms=DEFAULT_ELEMENT_TIMEOUT_MS,
            )

            await asyncio.sleep(1.0)

            logger.info(
                "Note deleted",
                notebook_id=notebook_id,
                note_index=note_index,
            )

            return True

        except Exception as e:
            if isinstance(e, ValueError):
                raise
            raise NotebookLMError(
                f"Failed to delete note: {e}",
                context={
                    "notebook_id": notebook_id,
                    "note_index": note_index,
                    "error": str(e),
                },
            ) from e
        finally:
            await page.close()

    # ---- Private helpers ----

    async def _extract_note_content(self, page: Any) -> str:
        """Extract note content from the editor or readonly viewer.

        Tries multiple selector strategies to extract the note body:
        1. Manual note editor (rich-text-editor with contenteditable)
        2. Readonly viewer (labs-tailwind-doc-viewer)
        3. Generic content area fallback

        Parameters
        ----------
        page : Any
            Playwright page object positioned on a notebook page
            with a note opened.

        Returns
        -------
        str
            The note content text, or empty string if not found.
        """
        # Strategy 1: Manual note editor (ProseMirror contenteditable)
        editor_selectors = self._selectors.get_selector_strings("note_editor_manual")
        for selector in editor_selectors:
            content = await extract_text(page, selector)
            if content:
                return content

        # Strategy 2: Readonly viewer (chat-saved notes)
        viewer_selectors = self._selectors.get_selector_strings("note_viewer_readonly")
        for selector in viewer_selectors:
            content = await extract_text(page, selector)
            if content:
                return content

        # Strategy 3: Generic fallback
        content = await extract_text(
            page,
            ".note-content, [data-type='note-content'], .note-body",
        )
        if content:
            return content

        logger.warning(
            "Note content not found",
            page_url=getattr(page, "url", "unknown"),
        )
        return ""


__all__ = [
    "NoteService",
]
