---
description: コード品質の自動改善（make check-all相当）
---

# コード品質の自動改善

**役割の明確化**: このコマンドは `make check-all` 相当の**自動修正**と**コード整理**を実行します。

- 検証・スコアリングのみ行いたい場合 → `/scan --validate`
- 分析レポートが欲しい場合 → `/analyze`
- エビデンスベースの改善実装 → `/improve`

## 実行内容

このコマンドは2つのフェーズで品質を向上させます：

### フェーズ1: 品質修正（quality-checker）
`make check-all`が成功するまで、自動的にコードを修正してコード品質を保証します。

### フェーズ2: コード整理（code-simplifier）
git diffで変更されたファイルを対象に、コードの整理とリファクタリングを実行します。

## 実行フロー

このコマンドは2つのサブエージェントを順次実行します。

### フェーズ1: 品質修正（quality-checker）

```yaml
subagent_type: "quality-checker"
description: "Auto-fix code quality issues"
prompt: |
  コード品質の自動修正を実行してください。

  ## モード
  --auto-fix

  ## 対象
  [指定されたパス、またはプロジェクト全体]

  ## 目標
  make check-all が成功するまで以下を繰り返し修正:
  1. make format - コードフォーマット
  2. make lint - リントチェック
  3. make typecheck - 型チェック
  4. make test - テスト実行

  ## 参照
  - CLAUDE.md のコーディング規約
  - template/ ディレクトリの実装例
```

### フェーズ2: コード整理（code-simplifier）

※品質修正（quality-checker）が成功した後に実行

```yaml
subagent_type: "code-simplifier"
description: "Simplify and refactor code"
prompt: |
  git diffで変更されたファイルのコード整理を実行してください。

  ## 対象
  git diff --name-only --diff-filter=ACMR '*.py' で検出されたPythonファイル

  ## 整理項目（優先度順）
  1. 型ヒント完全化（90%カバレッジ目標）
  2. ロギング実装（全関数に必須）
  3. エラーメッセージの具体性
  4. 命名統一（snake_case/PascalCase/UPPER_SNAKE_CASE）
  5. 関数分割（100行超過コードの分割）
  6. Docstring追加（NumPy形式）
  7. 重複削除（DRY原則）
  8. 複雑度低減（サイクロマティック複雑度21以上をリファクタ）

  ## 安全性
  - 1ファイルずつ段階的に修正
  - 各修正後に make test 実行
  - テスト失敗時は即座にロールバック
  - 動作を変える変更は一切行わない（リファクタリングのみ）

  ## 参照
  - CLAUDE.md のコーディング規約
  - docs/coding-standards.md の詳細規約
  - template/ ディレクトリの実装例
  - improvement-implementer の改善パターン
```

## 修正の順序

### フェーズ1: 品質修正

1. **コードフォーマット** (`make format`) - Ruff による自動フォーマット
2. **リントチェック** (`make lint`) - Ruff によるリントチェックと自動修正
3. **型チェック** (`make typecheck`) - pyright による厳格な型チェック
4. **テスト実行** (`make test`) - 全テストの実行

### フェーズ2: コード整理

1. **変更ファイル特定** - git diff で変更されたPythonファイルを検出
2. **分析とスコアリング** - 型ヒント、ロギング、関数長、複雑度、命名、Docstring、重複を評価
3. **優先度順に修正** - 高優先度（型ヒント、ロギング、関数分割）から順次実行
4. **テスト確認** - 各修正後に make test 実行、失敗したらロールバック

## 使用例

```bash
# プロジェクト全体の品質修正
/ensure-quality

# 特定のディレクトリの品質修正
/ensure-quality src/mylib/core/
```

## 実行フロー図

```
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  フェーズ1: 品質修正（quality-checker）                       │
│                                                             │
│  make check-all 実行                                        │
│       │                                                     │
│       ├─→ 成功 → フェーズ2へ                                │
│       │                                                     │
│       └─→ 失敗 → エラー種別を判定                           │
│              │                                              │
│              ├─→ フォーマット → make format → 再検証        │
│              ├─→ リント → make lint + 手動修正 → 再検証     │
│              ├─→ 型エラー → 型ヒント修正 → 再検証           │
│              └─→ テスト失敗 → 実装/テスト修正 → 再検証      │
│                                                             │
│  最大5回ループ後、未解決問題をレポート                       │
│                                                             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  フェーズ2: コード整理（code-simplifier）                     │
│                                                             │
│  git diff で変更ファイルを特定                               │
│       │                                                     │
│       ├─→ 変更なし → スキップ                               │
│       │                                                     │
│       └─→ 変更あり → 各ファイルを分析                       │
│              │                                              │
│              ├─→ 優先度順にソート                           │
│              │                                              │
│              └─→ 1ファイルずつ修正                          │
│                    │                                        │
│                    ├─→ 修正実行                             │
│                    ├─→ make test 実行                       │
│                    │      │                                 │
│                    │      ├─→ PASS → 次へ                   │
│                    │      └─→ FAIL → ロールバック           │
│                    │                                        │
│                    └─→ 全ファイル完了                       │
│                                                             │
│  最終レポート出力                                            │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 重要な注意事項

- **CLAUDE.md の規約に従う**: 型ヒント、エラーメッセージ、コーディングスタイルは CLAUDE.md の規約に準拠
- **既存の動作を保持**: テストが失敗した場合、まず実装が仕様通りかを確認し、必要に応じてテストも修正
- **段階的な修正**: 一度にすべてを修正せず、エラーの種類ごとに段階的に対処
- **進捗の報告**: 各ステップでの修正内容と結果を明確に報告

## エラー対処の具体例

### 型エラーの例

```python
# エラー: Incompatible return value type (got "None", expected "str")
def get_name() -> str:
    return None  # 修正前

# 修正後
def get_name() -> str | None:
    return None
```

### リントエラーの例

```python
# エラー: F401 'os' imported but unused
import os  # 修正: 未使用のインポートを削除

# エラー: E501 line too long (120 > 100 characters)
# 修正: 長い行を適切に改行
```

## 出力形式

```yaml
品質改善レポート:
  実行時間: [秒]

フェーズ1: 品質修正（quality-checker）
  修正サイクル数: [回]
  初期状態:
    フォーマット: [PASS/FAIL]
    リント: [PASS/FAIL] ([エラー数]件)
    型チェック: [PASS/FAIL] ([エラー数]件)
    テスト: [PASS/FAIL] ([失敗数]/[総数])

  実施した修正:
    - ファイル: [パス]
      問題: [問題の説明]
      修正: [修正内容]

  最終状態:
    make check-all: PASS

フェーズ2: コード整理（code-simplifier）
  対象ファイル数: [件]

  分析結果:
    高優先度: [件]
    中優先度: [件]
    低優先度: [件]

  実施した整理:
    成功:
      - ファイル: [パス]
        整理項目: [項目]
        改善内容: [内容]
        テスト結果: PASS

    失敗:
      - ファイル: [パス]
        整理項目: [項目]
        エラー: [エラー内容]
        対応: ロールバック完了

    スキップ:
      - ファイル: [パス]
        理由: [理由]

  統計:
    型ヒントカバレッジ: [前]% → [後]%
    平均関数長: [前]行 → [後]行
    平均複雑度: [前] → [後]
    Docstringカバレッジ: [前]% → [後]%

  最終状態:
    make test: PASS

統合結果:
  品質修正: ✅ 成功
  コード整理: ✅ 成功
  全体状況: ✅ プロジェクト品質向上完了
```

このコマンドを実行することで、プロジェクトのコード品質を一貫して高いレベルに保ち、コードの可読性と保守性も向上させることができます。
