---
name: analyze-conflicts
description: PRのコンフリクトを詳細分析し、問題点と解決策を提示。/analyze-conflictsコマンドで使用。
allowed-tools: Read, Bash
---

# PR コンフリクト分析スキル

> **役割の明確化**: このスキルは**コンフリクトの詳細分析**に特化しています。
>
> - PRのマージ実行 → `/merge-pr` コマンド
> - PRの詳細レビュー → `/review-pr` コマンド

## 目的

このスキルは以下を提供します：

- **PRコンフリクトの詳細分析**: 全てのコンフリクトファイル・問題点・解決策を提示
- **リスク評価**: コンフリクトの重要度とリスクレベルの判定
- **解決ガイド**: ステップバイステップの解決手順とベストプラクティス
- **自動解決候補の提示**: 安全に自動解決可能なコンフリクトの識別

## いつ使用するか

### プロアクティブ使用（自動で使用を検討）

以下の状況では、ユーザーが明示的に要求しなくても使用を検討してください：

1. **PRマージ時のコンフリクト検出**
   - `/merge-pr` 実行時にコンフリクトが検出された場合
   - PR作成時に "CONFLICTING" 状態を検出

2. **大規模なブランチマージ前**
   - 長期間分岐していたブランチのマージ
   - mainブランチから大きく乖離したfeatureブランチ

3. **マージの失敗**
   - Git merge コマンドでコンフリクトが発生
   - GitHub上でマージボタンが無効化されている

### 明示的な使用（ユーザー要求）

- `/analyze-conflicts` コマンド
- 「コンフリクトを分析して」などの直接的な要求
- PR番号またはブランチ名を指定した分析依頼

## プロセス

### ステップ 0: 前提条件の確認

#### 0.1 引数の確認

**引数（$ARGUMENTS）を解析**:
- PR番号: 必須（--localオプション使用時を除く）
- オプション: --local <branch>, --verbose, -v

**引数がない場合**: エラーを表示して処理を中断

```
エラー: PR番号またはブランチ名を指定してください。

使用方法:
  /analyze-conflicts <pr-number> [options]
  /analyze-conflicts --local <branch-name> [options]

オプション:
  --local <branch>  ローカルブランチのコンフリクトを分析
  --verbose, -v     コンフリクト箇所の詳細コードを表示

例:
  /analyze-conflicts 36
  /analyze-conflicts 36 --verbose
  /analyze-conflicts --local feature/my-branch
```

### ステップ 1: PR/ブランチ情報の取得

#### 1.1 PRモードの場合

```bash
gh pr view <pr-number> --json number,title,state,mergeable,mergeStateStatus,baseRefName,headRefName,url
```

**コンフリクトがない場合**:

```
✓ PR #<number> にコンフリクトはありません。

PR: <title>
状態: マージ可能

/merge-pr <number> でマージを実行できます。
```

#### 1.2 ローカルモードの場合

```bash
git rev-parse --verify <branch-name>
git merge-base main <branch-name>
```

### ステップ 2: コンフリクトファイルの特定

#### 2.1 PRモードでのコンフリクトファイル取得

GitHub APIではコンフリクトファイルの詳細が取得できないため、ローカルでシミュレート:

```bash
# 一時的にマージをシミュレート
git fetch origin
git checkout -B temp-conflict-check origin/<baseRefName>
git merge --no-commit --no-ff origin/<headRefName> 2>&1
```

#### 2.2 コンフリクトファイルの列挙

```bash
git diff --name-only --diff-filter=U
```

### ステップ 3: コンフリクトの詳細分析

#### 3.1 各ファイルのコンフリクト分析

各コンフリクトファイルについて以下を実行:

```bash
# コンフリクトマーカーの数をカウント
grep -c "^<<<<<<< " <file>

# コンフリクト箇所を抽出
grep -n -A 10 "^<<<<<<< " <file>
```

#### 3.2 コンフリクトの分類

| タイプ | 説明 | 検出方法 |
|--------|------|----------|
| 同一行変更 | 両ブランチで同じ行を変更 | マーカー間の行数が少ない |
| 隣接行変更 | 近接した行を変更 | コンテキスト重複 |
| 追加競合 | 同位置に異なる追加 | 追加行のみのコンフリクト |
| 削除競合 | 一方が削除、他方が変更 | 片側が空 |
| リネーム競合 | ファイル名変更の競合 | git statusで検出 |

### ステップ 4: 問題点の分析

#### 4.1 リスク評価

各コンフリクトについてリスクを評価:

| リスクレベル | 条件 | 説明 |
|--------------|------|------|
| **高** | ロジック変更の競合 | 両方でビジネスロジックが変更 |
| **高** | テストの競合 | テストケースが競合 |
| **中** | 型定義の競合 | 型・インターフェースが競合 |
| **中** | インポートの競合 | 依存関係が競合 |
| **低** | フォーマットの競合 | 空白・改行のみの差異 |
| **低** | コメントの競合 | コメント・ドキュメントのみ |

#### 4.2 依存関係の分析

コンフリクトファイル間の依存関係をチェック:

```bash
# インポート関係を確認
grep -l "from.*<conflicted_module>" src/**/*.py
```

### ステップ 5: 結果の出力

#### 5.1 サマリー表示

```
================================================================================
                      コンフリクト分析レポート
================================================================================

PR情報:
  番号: #<number>
  タイトル: <title>
  URL: <url>

ブランチ情報:
  ベース: <baseRefName>
  ヘッド: <headRefName>
  分岐点からのコミット数: <commit_count>

================================================================================
                         コンフリクトサマリー
================================================================================

コンフリクトファイル数: <count>
総コンフリクト箇所数: <total_conflicts>

リスク分布:
  高: <high_count> 件
  中: <medium_count> 件
  低: <low_count> 件

================================================================================
```

#### 5.2 ファイル別詳細

```
================================================================================
                      ファイル別コンフリクト詳細
================================================================================

[1/N] src/example/module.py
--------------------------------------------------------------------------------
リスクレベル: 高
コンフリクト箇所: 3 箇所
タイプ: 同一行変更

問題点:
  - L45-52: 両ブランチで `process_data` 関数のロジックを変更
  - L78-85: 例外ハンドリングの方法が異なる
  - L120-125: 戻り値の型が異なる

影響範囲:
  - このファイルをインポートしているモジュール: 5 個
  - 関連テスト: tests/unit/test_module.py

推奨解決策:
  1. main側の変更意図を確認（コミット: abc1234）
  2. feature側の変更意図を確認（コミット: def5678）
  3. 両方の変更を統合するか、どちらかを優先するか決定

--------------------------------------------------------------------------------

[2/N] src/example/types.py
--------------------------------------------------------------------------------
...
```

#### 5.3 verboseモード追加出力

```
================================================================================
                      コンフリクト箇所の詳細
================================================================================

[1/N] src/example/module.py:45-52
--------------------------------------------------------------------------------

<<<<<<< HEAD (main)
def process_data(data: list[dict]) -> ProcessResult:
    """Process data with validation."""
    validated = validate_all(data)
    return ProcessResult(items=validated, count=len(validated))
=======
def process_data(data: list[dict], strict: bool = False) -> ProcessResult:
    """Process data with optional strict mode."""
    if strict:
        validated = validate_strict(data)
    else:
        validated = validate_all(data)
    return ProcessResult(items=validated, count=len(validated), strict=strict)
>>>>>>> feature/my-branch

分析:
  - main: バリデーション処理をシンプルに維持
  - feature: strictモードオプションを追加
  - 統合案: strictオプションを追加しつつ、デフォルト動作は維持

--------------------------------------------------------------------------------
```

### ステップ 6: 解決ガイドの提示

#### 6.1 解決手順

```
================================================================================
                         解決ガイド
================================================================================

推奨される解決手順:

1. ローカルでの準備
   git fetch origin
   git checkout <headRefName>
   git merge origin/<baseRefName>

2. コンフリクトの解決（優先順位順）

   [優先度: 高] src/example/module.py
   - 両方の変更を理解してから統合
   - テストが通ることを確認

   [優先度: 中] src/example/types.py
   - 型定義の整合性を確認

   [優先度: 低] src/example/config.py
   - フォーマットのみの差異、どちらでも可

3. 解決後の確認
   make check-all

4. プッシュ
   git add .
   git commit -m "resolve: merge conflicts with main"
   git push

5. マージ
   /merge-pr <number>

================================================================================
```

#### 6.2 自動解決可能なコンフリクト

```
================================================================================
                      自動解決候補
================================================================================

以下のコンフリクトは自動解決が可能です:

| ファイル | 理由 | 推奨 |
|----------|------|------|
| pyproject.toml | バージョン番号のみ | main側を採用 |
| .gitignore | 追加行の競合 | 両方を採用 |

自動解決を実行しますか？
1. はい（上記ファイルを自動解決）
2. いいえ（手動で解決）
```

## 使用例

### 例1: PR番号を指定して分析

**状況**: PR #36がコンフリクトを起こしている

**入力**:
```bash
/analyze-conflicts 36
```

**期待される出力**:
```
================================================================================
                      コンフリクト分析レポート
================================================================================

PR #36: feat: add preset groups and enhanced ticker registry API

コンフリクトファイル: 3 件
  [高] src/market_analysis/registry.py (2箇所)
      - L45: レジストリ初期化ロジックの競合
      - L89: プリセット追加メソッドの競合

  [中] src/market_analysis/types.py (1箇所)
      - L23: TickerInfo型の定義競合

  [低] tests/conftest.py (1箇所)
      - L12: フィクスチャの順序競合

解決の推奨順序: registry.py → types.py → conftest.py
================================================================================
```

---

### 例2: 詳細モードで分析

**状況**: コンフリクト箇所の具体的なコードを確認したい

**入力**:
```bash
/analyze-conflicts 36 --verbose
```

**処理**:
1. 基本の分析レポートを生成
2. 各コンフリクト箇所のコード差分を追加表示
3. 両ブランチの変更意図を分析
4. 統合案を提示

---

### 例3: ローカルブランチの分析

**状況**: PRを作成する前にコンフリクトを確認したい

**入力**:
```bash
/analyze-conflicts --local feature/my-branch
```

**処理**:
1. ローカルブランチとmainのマージをシミュレート
2. コンフリクトを検出・分析
3. PR作成前に解決すべき問題を提示

---

### 例4: コンフリクトがない場合

**状況**: PRがマージ可能な状態

**入力**:
```bash
/analyze-conflicts 42
```

**期待される出力**:
```
✓ PR #42 にコンフリクトはありません。

PR: refactor: improve error handling in data processor
状態: マージ可能

/merge-pr 42 でマージを実行できます。
```

## オプション一覧

| オプション | 短縮形 | 説明 | デフォルト |
|------------|--------|------|------------|
| `--local` | - | ローカルブランチを分析 | - |
| `--verbose` | `-v` | 詳細なコード差分を表示 | - |

## 品質基準

このスキルの成果物は以下の品質基準を満たす必要があります：

### 必須（MUST）

- [ ] 全てのコンフリクトファイルを検出・列挙
- [ ] 各コンフリクトにリスクレベル（高/中/低）を割り当て
- [ ] 解決の推奨順序を提示
- [ ] 具体的な解決手順を提示
- [ ] PR情報（番号、タイトル、URL）を表示

### 推奨（SHOULD）

- 各コンフリクトの変更意図を分析
- 依存関係の影響範囲を分析
- 自動解決可能なコンフリクトを提案
- verboseモードでコード差分を表示
- 統合案を提案（可能な場合）

## エラーハンドリング

| 状況 | 対処 |
|------|------|
| PR番号未指定 | 使用方法を表示して終了 |
| PRが存在しない | エラーメッセージを表示して終了 |
| コンフリクトなし | 「マージ可能」と表示して終了 |
| ブランチが存在しない | エラーメッセージを表示して終了 |
| Git操作エラー | エラー詳細を表示して終了 |

## 完了条件

このスキルは以下の条件を満たした場合に完了とする：

- [ ] コンフリクトファイルが全て特定されている
- [ ] 各ファイルのリスクレベルが評価されている
- [ ] 解決ガイドが提示されている
- [ ] ユーザーが次のアクションを明確に理解できる

## 関連コマンド・スキル

### コマンド

| コマンド | 説明 |
|----------|------|
| `/merge-pr` | PRのマージ実行 |
| `/review-pr` | PRの詳細レビュー |
| `/commit-and-pr` | 変更のコミットとPR作成 |

### スキル

- **merge-pr**: PRマージプロセス（コンフリクト検出時にこのスキルを呼び出す）
- **git-rules**: Gitコミットメッセージ規約（コンフリクト解決後のコミットで参照）
