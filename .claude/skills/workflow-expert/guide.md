# ワークフロー設計ガイド

このガイドでは、複雑なタスクをワークフローとして設計する手順と、
マルチエージェント連携のベストプラクティスを解説します。

---

## Sequential Thinking による段階的計画

ワークフロー設計では、**必ず Sequential Thinking を使用して段階的に計画**してください。
複雑な設計を一度に行おうとすると、見落としや矛盾が生じやすくなります。

### Sequential Thinking の使用方法

MCP ツール `mcp__sequential-thinking__sequentialthinking` を使用します。

```yaml
# パラメータ
thought: "現在の思考ステップ"
thoughtNumber: 1  # 現在の思考番号
totalThoughts: 5  # 予想される総思考数（後で調整可能）
nextThoughtNeeded: true  # 次の思考が必要か
isRevision: false  # 前の思考を修正する場合は true
revisesThought: null  # 修正対象の思考番号
branchFromThought: null  # 分岐元の思考番号
branchId: null  # 分岐識別子
needsMoreThoughts: false  # 追加の思考が必要か
```

### ワークフロー設計での Sequential Thinking フロー

以下の順序で段階的に設計を進めます：

```
Thought 1: 要件の分析
    ↓
Thought 2: パターン候補の検討
    ↓
Thought 3: パターン選択と理由
    ↓
Thought 4: Phase 構造の設計
    ↓
Thought 5: エージェント割り当て
    ↓
Thought 6: データフローの設計
    ↓
Thought 7: エラーハンドリングの設計
    ↓
Thought 8: 仮説の検証と最終確認
```

### 具体的な実行例

#### Thought 1: 要件の分析

```json
{
  "thought": "ワークフローの要件を分析する。目的: 複数テーマのニュースを並列収集してGitHub Projectに投稿。入力: RSSフィード、既存Issue。出力: 新規Issue作成、サマリー。制約: テーマ別に独立した処理、重複チェック必須。",
  "thoughtNumber": 1,
  "totalThoughts": 6,
  "nextThoughtNeeded": true
}
```

#### Thought 2: パターン候補の検討

```json
{
  "thought": "パターン候補を検討する。(1) シーケンシャル: 各テーマを順番に処理 - 遅い、依存関係なし不要。(2) ファンアウト/ファンイン: 各テーマを並列処理後に集約 - 効率的、テーマが独立しているため適合。(3) オーケストレーター: セッション準備 + 並列ワーカー - データ準備が必要なため適合。",
  "thoughtNumber": 2,
  "totalThoughts": 6,
  "nextThoughtNeeded": true
}
```

#### Thought 3: パターン選択と理由

```json
{
  "thought": "パターン選択: オーケストレーター + ファンアウト/ファンイン の組み合わせ。理由: (1) RSSデータと既存Issueの事前取得が必要（オーケストレーター）、(2) 6テーマは独立して並列処理可能（ファンアウト）、(3) 結果サマリーで集約（ファンイン）。軽量オーケストレーターで十分。",
  "thoughtNumber": 3,
  "totalThoughts": 6,
  "nextThoughtNeeded": true
}
```

#### Thought 4: Phase 構造の設計

```json
{
  "thought": "Phase構造を設計する。Phase 0: 初期化 - RSSフィード取得、既存Issue取得、一時ファイル保存。Phase 1: テーマ別収集 - 6エージェント並列起動（index, stock, sector, macro, ai, finance）。Phase 2: 結果報告 - 各エージェントの処理結果をサマリー出力。",
  "thoughtNumber": 4,
  "totalThoughts": 6,
  "nextThoughtNeeded": true
}
```

#### Thought 5: エージェント割り当て

```json
{
  "thought": "エージェント割り当てを設計する。オーケストレーター: finance-news-orchestrator（セッション準備のみ）。ワーカー: finance-news-index, finance-news-stock, finance-news-sector, finance-news-macro, finance-news-ai, finance-news-finance（各テーマ専門）。各ワーカーは同じインターフェース: RSS記事フィルタリング → Issue作成 → 結果報告。",
  "thoughtNumber": 5,
  "totalThoughts": 6,
  "nextThoughtNeeded": true
}
```

#### Thought 6: 仮説の検証と最終確認

```json
{
  "thought": "設計の検証。(1) 要件との整合性: ✓ 並列処理で効率化、✓ テーマ別の独立処理、✓ 重複チェック（既存Issue参照）。(2) 潜在的問題: データ渡しでの情報欠落 → JSON形式で完全なデータを渡すルール適用。(3) エラーハンドリング: 部分成功パターン採用、失敗テーマのみログ出力。設計完了。",
  "thoughtNumber": 6,
  "totalThoughts": 6,
  "nextThoughtNeeded": false
}
```

### Sequential Thinking の重要なポイント

| ポイント | 説明 |
|---------|------|
| **柔軟な調整** | `totalThoughts` は途中で増減可能。複雑さに応じて調整 |
| **修正の記録** | 前の思考を修正する場合は `isRevision: true` と `revisesThought` を設定 |
| **分岐の活用** | 複数の選択肢を検討する場合は `branchFromThought` で分岐 |
| **不確実性の表現** | 曖昧な点は思考内で明示的に記述 |
| **仮説と検証** | 最終思考で設計の妥当性を検証 |

### 修正が必要な場合の例

```json
{
  "thought": "Thought 3 を修正する。オーケストレーター + ファンアウト/ファンイン に加えて、エラーリカバリーが必要なことに気づいた。失敗したテーマの再処理機能を追加する。",
  "thoughtNumber": 7,
  "totalThoughts": 8,
  "nextThoughtNeeded": true,
  "isRevision": true,
  "revisesThought": 3,
  "needsMoreThoughts": true
}
```

---

## ワークフロー設計手順

### ステップ 1: 要件の明確化

ワークフロー設計前に以下を明確にします：

```yaml
要件チェックリスト:
  - [ ] 目的: このワークフローで何を達成したいか
  - [ ] 入力: 何を受け取るか（データ、パラメータ）
  - [ ] 出力: 何を生成するか（成果物、レポート）
  - [ ] 制約: 時間、リソース、依存関係
  - [ ] 利用者: 誰がこのワークフローを使うか
```

**質問テンプレート**:
- 「このタスクの最終成果物は何か？」
- 「どのような入力が必要か？」
- 「どのような制約があるか？」
- 「自動化できる部分はどこか？」
- 「ユーザー判断が必要な点はどこか？」

### ステップ 2: タスクの分解

大きなタスクを小さな単位に分解します。

```
大タスク
├── サブタスク 1
│   ├── 処理 1.1
│   └── 処理 1.2
├── サブタスク 2
│   ├── 処理 2.1
│   └── 処理 2.2
└── サブタスク 3
```

**分解の原則**:

| 原則 | 説明 |
|------|------|
| **単一責任** | 1タスク = 1つの明確な目的 |
| **独立性** | 可能な限り他タスクへの依存を減らす |
| **検証可能性** | 完了を客観的に判定できる |
| **適切な粒度** | 細かすぎず、大きすぎない |

### ステップ 3: 依存関係の分析

タスク間の依存関係を分析し、実行順序を決定します。

```
タスクA ──────────┐
                  ├──→ タスクD ──→ タスクE
タスクB ──────────┤
                  │
タスクC ──────────┘
```

**依存関係マトリクス**:

| タスク | 前提タスク | 並列実行可能 |
|--------|-----------|-------------|
| タスクA | なし | ✅ |
| タスクB | なし | ✅ |
| タスクC | なし | ✅ |
| タスクD | A, B, C | ❌ |
| タスクE | D | ❌ |

### ステップ 4: パターン選択

要件と依存関係に基づいてワークフローパターンを選択します。

```yaml
パターン選択ガイド:
  シーケンシャル:
    条件: "依存関係が線形"
    例: "設計書作成 → 実装 → テスト"

  ファンアウト/ファンイン:
    条件: "独立処理が複数存在"
    例: "6テーマのニュース並列収集"

  オーケストレーター + ワーカー:
    条件: "複雑なPhase制御が必要"
    例: "テスト作成の並列実行と統合"

  ルーター + 専門家:
    条件: "入力に応じて処理を分岐"
    例: "Issue種別による実装ワークフロー分岐"

  批評・修正ループ:
    条件: "品質保証が重要"
    例: "記事の批評→修正サイクル"
```

### ステップ 5: Phase設計

選択したパターンに基づいてPhase構造を設計します。

**Phase設計テンプレート**:

```markdown
## Phase N: [Phase名]

### 目的
このPhaseで達成すること

### 入力
- [入力データ1]: [説明]
- [入力データ2]: [説明]

### 処理内容
1. [処理ステップ1]
2. [処理ステップ2]
3. [処理ステップ3]

### 出力
- [成果物1]: [説明]
- [成果物2]: [説明]

### 完了条件
- [ ] [検証項目1]
- [ ] [検証項目2]
- [ ] [検証項目3]

### エラーハンドリング
| エラー | 対処 |
|--------|------|
| [エラー1] | [対処法1] |
| [エラー2] | [対処法2] |
```

### ステップ 6: HFポイント設計

ヒューマンフィードバック（HF）ポイントを設計します。

```yaml
HFポイント設計:
  必須HF:
    - "重大な決定点（削除、公開、送信など）"
    - "複数の選択肢から選ぶ必要がある場合"
    - "曖昧さがあり確認が必要な場合"

  任意HF:
    - "中間成果物の確認"
    - "パラメータのカスタマイズ"

  スキップ可能:
    - "自動化テスト時（--skip-hf オプション）"
    - "定型的な処理の繰り返し"
```

**AskUserQuestion の設計**:

```yaml
question: "明確で具体的な質問文"
header: "短いラベル（12文字以内）"
options:
  - label: "選択肢1（推奨）"
    description: "この選択のメリットと結果"
  - label: "選択肢2"
    description: "この選択のメリットと結果"
  - label: "選択肢3"
    description: "この選択のメリットと結果"
```

### ステップ 7: エージェント割り当て

各Phaseまたはタスクにエージェントを割り当てます。

```yaml
エージェント割り当て:
  Phase 1:
    エージェント: "data-collector"
    責務: "データ収集"
    入力: "設定ファイル"
    出力: "生データ"

  Phase 2:
    エージェント: "data-analyzer"
    責務: "データ分析"
    入力: "Phase 1の出力"
    出力: "分析結果"
```

**エージェント設計の原則**:
- 1エージェント = 1つの明確な責務
- 必要最小限のツールアクセス
- スキル参照による知識の注入

### ステップ 8: データフロー設計

Phase間のデータ受け渡しを設計します。

```
Phase 1 ──[出力A]──→ Phase 2 ──[出力B]──→ Phase 3
            │
            └──[出力A']──→ Phase 2' ──[出力B']──┘
```

**データ渡しの原則**:

| 原則 | 説明 |
|------|------|
| **完全性** | データを省略せず完全に渡す |
| **JSON形式** | 構造化されたJSON形式で渡す |
| **一時ファイル活用** | 大量データは `.tmp/` に保存 |
| **トレーサビリティ** | セッションIDで追跡可能に |

参照: `.claude/rules/subagent-data-passing.md`

---

## スキル連携パターン

### パターン 1: 静的プリロード

エージェントのフロントマターで `skills:` を指定し、
スキルの完全なコンテンツをコンテキストに注入します。

```yaml
---
name: feature-implementer
skills:
  - coding-standards
  - tdd-development
  - error-handling
allowed-tools: Read, Edit, Bash, Grep, Task
---

# 機能実装エージェント

プリロードされたスキルの規約に従って実装してください。
```

**特徴**:
- エージェント起動時に自動的にスキルがロードされる
- スキルの完全なコンテンツがコンテキストに含まれる
- サブエージェントは親からスキルを継承しない

**使用例**:
- コーディング規約の適用
- テスト戦略の適用
- エラーハンドリングパターンの適用

### パターン 2: 動的スキル呼び出し

Skill tool を使用して実行時にスキルを呼び出します。

```yaml
# ユーザーからの明示的な呼び出し
/workflow-expert

# エージェント内からの呼び出し
Skill tool で "workflow-expert" を呼び出す
```

**特徴**:
- 必要な時にのみスキルをロード
- コンテキスト使用量を最適化
- ユーザーが直接スキルを呼び出せる

**使用例**:
- ユーザー主導のワークフロー設計
- 特定の専門知識が必要な場合

### パターン 3: スキルのカスケード

スキルが別のスキルを参照する構造です。

```
command-expert
    └── skills: [workflow-expert]
                    └── リソース: guide.md, patterns.md
```

**設計ガイドライン**:

| 項目 | 推奨 |
|------|------|
| **深さ** | 最大2レベル |
| **スキル数** | エージェントあたり1-3個 |
| **粒度** | 大きなスキル + 内部モジュール分割 |

### パターン 4: スキルリソースの参照

スキル内のリソースファイル（guide.md, template.md）を
エージェントや他のスキルが参照します。

```markdown
## リソース

### ./guide.md
[ガイドの内容をここで参照]

### ./template.md
[テンプレートの内容をここで参照]
```

**ベストプラクティス**:
- リソースは SKILL.md から相対パスで参照
- 大きなコンテンツは別ファイルに分離
- テンプレートは例を含める

---

## オーケストレーション設計

### オーケストレーターの種類

#### 軽量オーケストレーター

```yaml
責務:
  - セッション準備（データ収集、設定読み込み）
  - ワーカーへのデータ配布
  - 結果サマリーの生成

やらないこと:
  - 複雑なPhase制御
  - エラーリカバリー
  - ワーカー間の調整
```

**実装例**: `finance-news-orchestrator`

```markdown
## 処理フロー

1. RSSフィードからニュース取得
2. 既存Issueを取得（重複チェック用）
3. 一時ファイルにデータ保存
4. ワーカー（テーマエージェント）を並列起動
5. 結果サマリーを出力
```

#### 完全オーケストレーター

```yaml
責務:
  - Phase間の制御
  - 並列実行の管理
  - エラーリカバリー
  - 進捗追跡と報告
  - 中間結果の検証

特徴:
  - 複雑な依存関係を処理
  - 条件分岐をサポート
  - ロールバック機能
```

**実装例**: `test-orchestrator`

```markdown
## 処理フロー

Phase 1: テスト設計（test-planner）
    │
Phase 2: 並列テスト作成
    ├── test-unit-writer（並列）
    └── test-property-writer（並列）
    │
Phase 3: 統合テスト作成（test-integration-writer）
    │
    ↓ 全完了後
Phase 4: 検証と報告
```

### 並列実行の設計

#### Task tool での並列起動

```yaml
# 単一メッセージで複数のTask toolを呼び出す
Task 1:
  subagent_type: "worker-a"
  prompt: "タスクA実行"

Task 2:
  subagent_type: "worker-b"
  prompt: "タスクB実行"

Task 3:
  subagent_type: "worker-c"
  prompt: "タスクC実行"
```

**重要**: 並列実行するには、**単一メッセージ内で複数のTask tool**を呼び出す必要があります。

#### 並列実行の条件

```yaml
並列実行可能:
  - タスク間に依存関係がない
  - 同じリソースへの同時書き込みがない
  - 処理順序が結果に影響しない

並列実行不可:
  - 前タスクの出力が次タスクの入力
  - 同じファイルへの書き込み
  - データベーストランザクション
```

### 結果の集約

```yaml
集約パターン:
  サマリー:
    - 各ワーカーの成功/失敗状態
    - 処理件数の合計
    - 重要な結果のハイライト

  詳細ログ:
    - 各ワーカーの完全な出力
    - エラーの詳細
    - 処理時間

  アクションアイテム:
    - 失敗した処理のリトライ指示
    - ユーザー確認が必要な項目
```

---

## エラーハンドリングパターン

### パターン 1: リトライ

```yaml
リトライ戦略:
  最大回数: 3
  間隔: 指数バックオフ（1s, 2s, 4s）
  条件: 一時的なエラー（ネットワーク、タイムアウト）

実装:
  attempt: 1
  while attempt <= 3:
    try:
      execute_task()
      break
    except TransientError:
      wait(2 ** attempt seconds)
      attempt += 1
```

**適用ケース**:
- API呼び出しの一時的な失敗
- ネットワークタイムアウト
- 一時的なリソース不足

### パターン 2: フォールバック

```yaml
フォールバック戦略:
  優先: 高速/低コスト手法
  代替: 確実/高コスト手法

実装:
  try:
    result = fast_method()
  except FastMethodError:
    result = reliable_method()
```

**適用ケース**:
- キャッシュ → データベース
- API → ローカルファイル
- 自動処理 → ユーザー確認

### パターン 3: 部分成功

```yaml
部分成功戦略:
  並列処理時:
    - 成功した結果は保持
    - 失敗した項目のみリトライ
    - 最終的な成功/失敗を集計

実装:
  results = []
  failures = []
  for task in tasks:
    try:
      results.append(execute(task))
    except Error as e:
      failures.append((task, e))

  # 失敗のみリトライ
  for task, error in failures:
    retry_result = retry(task)
```

**適用ケース**:
- バッチ処理
- 複数ファイルの処理
- 並列API呼び出し

### パターン 4: ロールバック

```yaml
ロールバック戦略:
  チェックポイント:
    - 重要な状態変更前に保存
    - Phase完了時に保存
    - エラー時に復元

実装:
  checkpoint = save_state()
  try:
    execute_phase()
  except CriticalError:
    restore_state(checkpoint)
    raise
```

**適用ケース**:
- データベース操作
- ファイルシステム変更
- 設定変更

### パターン 5: エスカレーション

```yaml
エスカレーション戦略:
  自動処理:
    - 軽微なエラーは自動修正
    - ログに記録

  警告:
    - 自動修正できるが影響が大きい
    - ユーザーに通知

  確認要求:
    - 自動修正できない
    - ユーザーの判断が必要

  中断:
    - クリティカルエラー
    - 処理を中断して報告
```

**実装例**:

```markdown
## エラー時の対処

| エラーレベル | 対処 |
|-------------|------|
| INFO | ログ記録、処理継続 |
| WARNING | ログ記録、ユーザー通知、処理継続 |
| ERROR | ユーザー確認を要求 |
| CRITICAL | 処理中断、詳細レポート出力 |
```

### エラーハンドリング設計テンプレート

```markdown
## Phase N: エラーハンドリング

### 想定されるエラー

| エラー | 原因 | 影響 | 対処 |
|--------|------|------|------|
| APIタイムアウト | ネットワーク遅延 | 低 | リトライ（3回） |
| 認証エラー | トークン期限切れ | 中 | ユーザーに再認証を要求 |
| データ不整合 | 並行更新 | 高 | ロールバック、ユーザー確認 |

### リカバリー手順

1. エラーをログに記録
2. 適切な対処パターンを選択
3. リカバリー実行
4. 結果を検証
5. 必要に応じてユーザーに報告
```

---

## ワークフロー品質チェックリスト

### 設計フェーズ

- [ ] 目的と成果物が明確に定義されている
- [ ] 入力/出力が具体的に記述されている
- [ ] タスクが適切な粒度に分解されている
- [ ] 依存関係が分析されている
- [ ] 並列実行可能な処理が特定されている

### Phase設計

- [ ] 各Phaseの目的が単一で明確
- [ ] 入力/出力が定義されている
- [ ] 完了条件がチェックリスト形式
- [ ] エラーハンドリングが定義されている
- [ ] HFポイントが適切に配置されている

### エージェント設計

- [ ] 各エージェントの責務が単一
- [ ] 必要最小限のツールアクセス
- [ ] スキル参照が適切
- [ ] データ渡しが完全なJSON形式

### テスト可能性

- [ ] 各Phaseを個別にテスト可能
- [ ] エラーケースがテスト可能
- [ ] 成功条件が客観的に検証可能

---

## よくある問題と解決策

### 問題 1: ワークフローが複雑すぎる

**症状**: Phase数が10以上、理解が困難

**解決策**:
1. 関連するPhaseをグループ化
2. サブワークフローとして分離
3. オーケストレーターを導入

### 問題 2: エージェント間のデータ不整合

**症状**: 後続Phaseでデータが欠落

**解決策**:
1. データ渡しルールを厳守（`.claude/rules/subagent-data-passing.md`）
2. 一時ファイルを使用
3. データ検証ステップを追加

### 問題 3: 並列処理の競合

**症状**: 同じリソースへの同時アクセスでエラー

**解決策**:
1. 書き込みは逐次処理に変更
2. ロック機構を導入
3. 処理対象を分割

### 問題 4: エラーリカバリーが不十分

**症状**: エラー後の状態が不明確

**解決策**:
1. 各Phaseでチェックポイントを設定
2. ロールバック手順を定義
3. 詳細なエラーレポートを出力

### 問題 5: ユーザーインタラクションが多すぎる

**症状**: 頻繁な確認要求でワークフローが中断

**解決策**:
1. バッチ承認を導入
2. デフォルト値を設定
3. 重要な決定点のみHFを要求

---

## 参考実装

| ワークフロー | パターン | 参照先 |
|-------------|---------|--------|
| Issue自動実装 | シーケンシャル + ルーター | `.claude/commands/issue-implement.md` |
| ニュース収集 | ファンアウト/ファンイン | `.claude/commands/collect-finance-news.md` |
| 記事執筆 | 批評・修正ループ | `.claude/commands/finance-full.md` |
| テスト作成 | オーケストレーター | `.claude/agents/test-orchestrator.md` |
| PRレビュー | ファンアウト/ファンイン | `.claude/commands/review-pr.md` |
