"""
weekly_report_generator.py

週次米国株式市場レポート作成のためのデータ取得・分析ツール。
AIエージェントが「ツール」として呼び出すことを想定し、JSON形式で結果を出力する。
既存の `market_report_utils.py` を利用するが、変更は加えない。
"""

import argparse
import json
import sys
import datetime
import pandas as pd
import numpy as np
from pathlib import Path

# srcディレクトリにパスを通す（market_report_utilsをインポートするため）
sys.path.append(str(Path(__file__).parent))
# srcの親ディレクトリ(Quants)にもパスを通す（market_report_utils内で from src... をしているため）
sys.path.append(str(Path(__file__).parent.parent))

from market_report_utils import MarketPerformanceAnalyzer
from fred_database_utils import FredDataProcessor
from calendar_utils import MacroCalendar, EarningsCalendar

# =========================================================================================
# 定数定義
# =========================================================================================
TICKER_GROWTH = "VUG"
TICKER_VALUE = "VTV"

# =========================================================================================
class WeeklyReportGenerator:
    def __init__(self):
        self.analyzer = MarketPerformanceAnalyzer()
        # デフォルトは2年分しか取得しないため、長期リターン計算用に10年分再取得する
        raw_df = self.analyzer.yf_download_with_curl(self.analyzer.ALL_TICKERS, period="10y")
        self.price_data = (
            raw_df.loc[raw_df["variable"] == "Adj Close"]
            .pivot(index="Date", columns="Ticker", values="value")
            .astype(float)
        ).dropna(subset=list(self.analyzer.SECTOR_MAP_EN.keys()))
        self.today = datetime.date.today()

        # FREDデータプロセッサ
        self.fred_processor = FredDataProcessor()
        self.fred_db_path = Path(self.fred_processor.data_dir) / "FRED.db"

    def _calculate_metrics(self, df: pd.DataFrame, ticker: str) -> dict:
        """
        指定されたティッカーについて、各種期間のリターンと効率性を計算する。
        """
        if ticker not in df.columns:
            return {}

        series = df[ticker].dropna()
        if series.empty:
            return {}

        current_price = series.iloc[-1]
        current_date = series.index[-1].date()

        metrics = {
            "price": round(current_price, 2),
            "date": str(current_date),
            "returns": {},
            "efficiency": {}
        }

        # --- 期間設定 ---
        periods = {
            "daily": 1, # 1営業日前
            "weekly": 5, # 5営業日前
            "1y": 252,
            "3y": 252 * 3,
            "5y": 252 * 5
        }

        # --- リターン計算 (Daily, Weekly, 1Y, 3Y, 5Y) ---
        for name, days in periods.items():
            if len(series) > days:
                prev_price = series.iloc[-(days + 1)]
                ret = ((current_price / prev_price) - 1) * 100
                metrics["returns"][name] = round(ret, 2)

                # 効率性 (1Y以上)
                if days >= 252:
                    # 期間中の日次リターン
                    period_series = series.iloc[-(days + 1):]
                    daily_returns = period_series.pct_change().dropna()

                    # 年率リターン (単純化: 期間トータルリターンを年数で割るのではなく、幾何平均を使うべきだが、
                    # ここではユーザー要望の「平均リターン/ボラティリティ」に合わせて
                    # 年率平均リターン = 日次リターンの平均 * 252
                    # 年率ボラティリティ = 日次リターンの標準偏差 * sqrt(252)
                    # とする)

                    avg_ret_annualized = daily_returns.mean() * 252 * 100
                    vol_annualized = daily_returns.std() * np.sqrt(252) * 100

                    if vol_annualized != 0:
                        efficiency = avg_ret_annualized / vol_annualized
                        metrics["efficiency"][name] = round(efficiency, 2)

        # --- MTD (Month to Date) ---
        current_month_start = current_date.replace(day=1)
        # 月初より前の直近データを探す
        month_start_data = series.loc[series.index.date < current_month_start]
        if not month_start_data.empty:
            prev_month_close = month_start_data.iloc[-1]
            mtd_ret = ((current_price / prev_month_close) - 1) * 100
            metrics["returns"]["mtd"] = round(mtd_ret, 2)

        # --- YTD (Year to Date) ---
        current_year_start = current_date.replace(month=1, day=1)
        # 年初より前の直近データを探す
        year_start_data = series.loc[series.index.date < current_year_start]
        if not year_start_data.empty:
            prev_year_close = year_start_data.iloc[-1]
            ytd_ret = ((current_price / prev_year_close) - 1) * 100
            metrics["returns"]["ytd"] = round(ytd_ret, 2)

        return metrics

    def get_indices(self):
        """主要指数のメトリクスを取得"""
        targets = ["^SPX", "^SPXEW", TICKER_GROWTH, TICKER_VALUE]
        result = {}
        for ticker in targets:
            name = ticker
            if ticker == TICKER_GROWTH: name = "Growth (VUG)"
            if ticker == TICKER_VALUE: name = "Value (VTV)"

            data = self._calculate_metrics(self.price_data, ticker)
            if data:
                data["ticker"] = ticker
                result[name] = data
        return result

    def get_mag7(self):
        """Mag7 + SOXのメトリクスを取得"""
        targets = self.analyzer.TICKERS_MAG7_AND_SOX
        result = {}
        for ticker in targets:
            data = self._calculate_metrics(self.price_data, ticker)
            if data:
                result[ticker] = data

        # 週間リターンでソートして返す
        sorted_result = dict(sorted(result.items(), key=lambda item: item[1]["returns"].get("weekly", -999), reverse=True))
        return sorted_result

    def get_sectors(self):
        """セクター別メトリクスを取得"""
        sector_tickers = list(self.analyzer.SECTOR_MAP_EN.keys())
        result = {}
        for ticker in sector_tickers:
            sector_name = self.analyzer.SECTOR_MAP_EN[ticker]
            data = self._calculate_metrics(self.price_data, ticker)
            if data:
                data["ticker"] = ticker
                result[sector_name] = data

        # 週間リターンでソート
        sorted_sectors = sorted(result.items(), key=lambda item: item[1]["returns"].get("weekly", -999), reverse=True)

        return {
            "ranked_sectors": {k: v for k, v in sorted_sectors},
            "top3": [{"name": k, "data": v} for k, v in sorted_sectors[:3]],
            "bottom3": [{"name": k, "data": v} for k, v in sorted_sectors[-3:]]
        }

    def get_macro(self):
        """
        マクロ指標を取得 (FREDデータ + 市場データ)
        - 金利: DGS2, DGS10, T10Y2Y
        - クレジット: BAMLC0A0CM, BAMLH0A0HYM2
        - 不確実性: VIXCLS, USEPUINDXD
        - 通貨: DTWEXBGS
        """
        # FREDからデータを取得
        fred_series_ids = [
            "DGS2", "DGS10", "T10Y2Y",
            "BAMLC0A0CM", "BAMLH0A0HYM2",
            "VIXCLS", "USEPUINDXD",
            "DTWEXBGS"
        ]

        # DBからロード (なければAPI取得されるはずだが、基本はDB前提)
        # FredDataProcessor.load_data_from_database は DataFrame(date, value, variable) を返す
        try:
            fred_df = self.fred_processor.load_data_from_database(
                db_path=self.fred_db_path,
                series_id_list=fred_series_ids
            )

            # ピボットして使いやすくする
            fred_pivot = fred_df.pivot(index="date", columns="variable", values="value").sort_index()
        except Exception as e:
            print(f"Warning: Failed to load FRED data: {e}")
            fred_pivot = pd.DataFrame()

        result = {}

        # 各シリーズについて直近値と週間変化を計算
        for series_id in fred_series_ids:
            if series_id in fred_pivot.columns:
                series = fred_pivot[series_id].dropna()
                if not series.empty:
                    current = series.iloc[-1]
                    current_date = series.index[-1]

                    # 週間変化 (5営業日前との差分)
                    if len(series) >= 6:
                        prev = series.iloc[-6]
                        change = current - prev
                    else:
                        change = 0

                    result[series_id] = {
                        "current": round(current, 2),
                        "weekly_change": round(change, 2),
                        "date": current_date.strftime('%Y-%m-%d')
                    }

        # 市場データ (VIXなどyfinanceで取れるものがあれば補完)
        # 今回はFRED優先だが、速報性が必要ならyfinanceの ^VIX なども検討可

        return result

    def get_commodities(self):
        """
        コモディティ関連のパフォーマンスを取得
        - 金属: GLD, SLV, DBB (産業用金属)
        - エネルギー: CL=F (原油)
        - 素材: XLB (化学含む)
        - 比較対象: 米ドル指数 (DTWEXBGS from FRED)
        """
        targets = ["GLD", "SLV", "DBB", "CL=F", "XLB"]
        result = {}

        for ticker in targets:
            data = self._calculate_metrics(self.price_data, ticker)
            if data:
                result[ticker] = data

        # 米ドル指数との比較用データ (FRED)
        # 直近の相関などを計算したいが、ここではシンプルにトレンド比較のためのデータを返す
        try:
            fred_df = self.fred_processor.load_data_from_database(
                db_path=self.fred_db_path,
                series_id_list=["DTWEXBGS"]
            )
            if not fred_df.empty:
                usd_series = fred_df[fred_df["variable"] == "DTWEXBGS"].set_index("date")["value"].sort_index()

                # 直近の週間リターンを計算
                if len(usd_series) >= 6:
                    curr = usd_series.iloc[-1]
                    prev = usd_series.iloc[-6]
                    usd_weekly_return = ((curr / prev) - 1) * 100

                    result["USD_Index"] = {
                        "ticker": "DTWEXBGS",
                        "returns": {
                            "weekly": round(usd_weekly_return, 2)
                        },
                        "current": round(curr, 2),
                        "date": usd_series.index[-1].strftime('%Y-%m-%d')
                    }
        except Exception as e:
            print(f"Warning: Failed to load USD Index data: {e}")

        return result

    def get_events(self):
        """
        今後のイベント予定を取得
        - マクロ指標 (FRED)
        - 決算発表 (yfinance - Mag7 + 主要セクター + ユニバース)
        """
        macro_cal = MacroCalendar()
        earnings_cal = EarningsCalendar()

        # マクロ指標
        macro_events = macro_cal.get_upcoming_releases(days=14)

        # 決算発表
        # Mag7は必須
        mag7 = self.analyzer.TICKERS_MAG7_AND_SOX
        # 処理時間を考慮し、今回はMag7 + 主要セクターETFのみとするか、
        # ユニバース全体をやるかは実行時のオプションにしたいが、
        # ここでは「網羅的」という要望に応え、ユニバース全体を対象とする。
        # ただし、API制限や時間を考慮し、まずはMag7を優先リストとして表示し、
        # ユニバース全体はバックグラウンド的に取得するか、あるいは主要銘柄に絞る。

        # 実用性を考え、Mag7 + 主要セクターETF + 注目銘柄リスト を対象とする
        # ユニバース全体(1000銘柄以上)のTicker.calendar取得は非常に時間がかかるため、
        # ここではMag7と主要セクターETF、およびダウ構成銘柄程度に留めるのが現実的。
        # ユーザー要望の「ユニバース全体」は、別途バッチ処理でDB化しておくのが正解だが、
        # 今回はオンデマンド実行のため、対象を絞る。

        target_tickers = mag7 + list(self.analyzer.SECTOR_MAP_EN.keys()) + ["^DJI"]
        # 必要であればここにユニバースから抽出したリストを追加するが、今回はパフォーマンス優先で絞る。
        # ユーザーには「主要銘柄」として提示する。

        earnings_events = earnings_cal.get_upcoming_earnings(tickers=target_tickers, days=14)

        return {
            "macro": macro_events,
            "earnings": earnings_events
        }

    def generate_draft(self, save=False):
        """レポートドラフトを生成"""
        indices = self.get_indices()
        mag7 = self.get_mag7()
        sectors = self.get_sectors()
        macro = self.get_macro()
        commodities = self.get_commodities()
        events = self.get_events()

        end_date = self.today
        start_date = end_date - datetime.timedelta(days=6)

        md = f"# {start_date.strftime('%Y/%m/%d')}(Mon) - {end_date.strftime('%Y/%m/%d')}(Sun) Weekly Comment\n\n"

        md += f"## Indices (AS OF {end_date.strftime('%m/%d')})\n\n"
        for name, data in indices.items():
            ret = data["returns"].get("weekly", "N/A")
            sign = "+" if isinstance(ret, (int, float)) and ret > 0 else ""
            md += f"- {name}: {sign}{ret}%\n"
        md += "\n[週全体の動向説明] <!-- SEARCH_REQUIRED: 市場全体の動向と要因 -->\n\n"

        # マクロ動向セクションを追加
        md += "## マクロ経済・金融政策の動向\n\n"
        md += "### 主要指標の週間変化\n"
        if "DGS10" in macro:
            md += f"- 米国10年債利回り: {macro['DGS10']['current']}% (週間変化: {macro['DGS10']['weekly_change']}bps)\n"
        if "T10Y2Y" in macro:
            md += f"- 10年-2年金利差: {macro['T10Y2Y']['current']}% (週間変化: {macro['T10Y2Y']['weekly_change']}bps)\n"
        if "BAMLC0A0CM" in macro:
            md += f"- 投資適格社債スプレッド: {macro['BAMLC0A0CM']['current']}% (週間変化: {macro['BAMLC0A0CM']['weekly_change']}bps)\n"
        if "VIXCLS" in macro:
            md += f"- VIX指数: {macro['VIXCLS']['current']} (週間変化: {macro['VIXCLS']['weekly_change']})\n"
        md += "\n[マクロ動向の解説] <!-- SEARCH_REQUIRED: 金利変動の背景、金融政策への思惑 -->\n\n"

        md += "## Magnificent 7\n\n"
        for ticker, data in mag7.items():
            ret = data["returns"].get("weekly", "N/A")
            sign = "+" if isinstance(ret, (int, float)) and ret > 0 else ""
            md += f"- {ticker}: {sign}{ret}%\n"
        md += "\n[各銘柄の動向説明] <!-- SEARCH_REQUIRED: Mag7各銘柄のニュース -->\n\n"

        md += "## セクター別パフォーマンス\n\n"
        md += "### 上位3セクター\n\n"
        for i, item in enumerate(sectors["top3"], 1):
            name = item["name"]
            ret = item["data"]["returns"].get("weekly", "N/A")
            sign = "+" if isinstance(ret, (int, float)) and ret > 0 else ""
            md += f"**{i}. {name}: {sign}{ret}%**\n"
            md += f"[説明] <!-- SEARCH_REQUIRED: {name}セクターの上昇要因 -->\n\n"

        md += "### 下位3セクター\n\n"
        for i, item in enumerate(sectors["bottom3"], 1):
            name = item["name"]
            ret = item["data"]["returns"].get("weekly", "N/A")
            sign = "+" if isinstance(ret, (int, float)) and ret > 0 else ""
            md += f"**{i}. {name}: {sign}{ret}%**\n"
            md += f"[説明] <!-- SEARCH_REQUIRED: {name}セクターの下落要因 -->\n\n"

        # コモディティセクションを追加
        md += "## コモディティ・為替動向\n\n"
        if "USD_Index" in commodities:
             md += f"- 米ドル指数 (Trade Weighted): {commodities['USD_Index']['current']} (週間: {commodities['USD_Index']['returns']['weekly']}%)\n"

        md += "### 主要コモディティ\n"
        comm_list = ["GLD", "SLV", "DBB", "CL=F", "XLB"]
        for ticker in comm_list:
            if ticker in commodities:
                ret = commodities[ticker]["returns"].get("weekly", "N/A")
                sign = "+" if isinstance(ret, (int, float)) and ret > 0 else ""
                name = ticker
                if ticker == "DBB": name = "産業用金属 (DBB)"
                if ticker == "XLB": name = "素材セクター (XLB)"
                if ticker == "CL=F": name = "原油 (WTI)"
                md += f"- {name}: {sign}{ret}%\n"
        md += "\n[コモディティ動向の解説] <!-- SEARCH_REQUIRED: 原油、金属価格の変動要因とドルとの関係 -->\n\n"

        md += "## 今後の材料\n\n"
        md += "### マクロ経済指標発表予定\n"
        for event in events["macro"]:
            md += f"- {event['date']}: {event['name']}\n"

        md += "\n### 主な決算発表予定\n"
        for event in events["earnings"]:
            md += f"- {event['date']}: {event['ticker']}\n"

        md += "\n[その他注目イベント] <!-- SEARCH_REQUIRED: その他政治イベントなど -->\n\n"

        result = {
            "content": md,
            "indices": indices,
            "mag7": mag7,
            "sectors": sectors,
            "macro": macro,
            "commodities": commodities,
            "events": events
        }

        if save:
            date_str = end_date.strftime('%Y%m%d')
            output_dir = Path(f"../../Equity_Research/00_Weekly-Comment/{date_str}")
            output_dir.mkdir(parents=True, exist_ok=True)
            file_path = output_dir / f"{date_str}_weekly_comment.md"
            with open(file_path, "w", encoding="utf-8") as f:
                f.write(md)
            result["saved_path"] = str(file_path)

        return result

# =========================================================================================
# Main
# =========================================================================================
def main():
    parser = argparse.ArgumentParser(description="Weekly Market Report Generator")
    parser.add_argument("--action", required=True, choices=["get_indices", "get_mag7", "get_sectors", "get_macro", "get_commodities", "get_events", "generate_draft"], help="Action to perform")
    parser.add_argument("--save", action="store_true", help="Save the draft to file (only for generate_draft)")

    args = parser.parse_args()

    generator = WeeklyReportGenerator()

    result = {}
    try:
        if args.action == "get_indices":
            result = generator.get_indices()
        elif args.action == "get_mag7":
            result = generator.get_mag7()
        elif args.action == "get_sectors":
            result = generator.get_sectors()
        elif args.action == "get_macro":
            result = generator.get_macro()
        elif args.action == "get_commodities":
            result = generator.get_commodities()
        elif args.action == "get_events":
            result = generator.get_events()
        elif args.action == "generate_draft":
            result = generator.generate_draft(save=args.save)

        print(json.dumps(result, indent=4, ensure_ascii=False))

    except Exception as e:
        print(json.dumps({"error": str(e)}, indent=4, ensure_ascii=False))
        sys.exit(1)

if __name__ == "__main__":
    main()
